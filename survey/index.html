<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Survey Application</title>
  <!-- Add Supabase CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="stylesheet" href="styles.css">
  <style>
    /* Loading state styles */
    .nav-btn.loading {
      position: relative;
      color: transparent;
      pointer-events: none;
    }

    .nav-btn.loading::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      top: 50%;
      left: 50%;
      margin-left: -8px;
      margin-top: -8px;
      border: 2px solid #ffffff;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 1s linear infinite;
    }

    .form-disabled {
      pointer-events: none;
      opacity: 0.6;
    }

    .form-disabled .scale-slider,
    .form-disabled .text-input,
    .form-disabled .select-input {
      cursor: not-allowed;
    }

    .time-estimate {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: #666;
      font-weight: 600;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div class="progress-bar-container">
    <div class="progress-bottom">
      <div class="progress-text" id="progress-text">0%</div>
      <div class="time-estimate" id="time-estimate">5min to complete</div>
      <button class="reset-btn" id="reset-btn" onclick="resetSurvey()">Reset Survey</button>
    </div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
  </div>

  <div class="title-card">
    <div class="title-section">
      <h1 id="form-title">Loading...</h1>
      <p id="form-description"></p>
    </div>
  </div>

  <div class="container">
    <div id="success-view" class="success-view">
      <div class="success-icon">âœ“</div>
      <h2 class="success-title">Thank You!</h2>
      <p class="success-message">
        Your survey responses have been successfully submitted. We appreciate your valuable feedback and the time you
        took to complete this survey.
      </p>
      <div class="success-actions">
        <button class="success-btn" onclick="viewResponses()">View My Responses</button>
      </div>
    </div>

    <form id="survey-form">
      <!-- Sections will be populated here -->
    </form>
  </div>

  <script src="supabase-utils.js"></script>
  <script>
    let surveyData = null;
    let responses = {};
    let currentSectionIndex = 0;
    let completedSections = new Set(); // Track which sections have been completed
    let interactedQuestions = new Set(); // Track which questions have been interacted with
    let isReadOnlyMode = false; // Track if we're in read-only mode
    let isSubmitting = false; // Track if form is being submitted

    // Local storage keys
    const STORAGE_KEY = 'survey_state';
    const SUBMITTED_KEY = 'survey_submitted';

    // Submission flag management
    function setSurveySubmitted() {
      try {
        localStorage.setItem(SUBMITTED_KEY, 'true');
      } catch (error) {
        console.warn('Failed to set submission flag:', error);
      }
    }

    function isSurveySubmitted() {
      try {
        return localStorage.getItem(SUBMITTED_KEY) === 'true';
      } catch (error) {
        console.warn('Failed to check submission flag:', error);
        return false;
      }
    }

    function clearSubmissionFlag() {
      try {
        localStorage.removeItem(SUBMITTED_KEY);
      } catch (error) {
        console.warn('Failed to clear submission flag:', error);
      }
    }

    // Show success view
    function showSuccessView() {
      document.getElementById('success-view').classList.add('active');
      document.getElementById('survey-form').style.display = 'none';

      // Update progress to 100%
      document.getElementById('progress-fill').style.width = '100%';
      document.getElementById('progress-text').textContent = '100%';
    }

    // Hide success view
    function hideSuccessView() {
      document.getElementById('success-view').classList.remove('active');
      document.getElementById('survey-form').style.display = 'block';
    }

    // Start new survey
    function startNewSurvey() {
      if (confirm('Are you sure you want to start a new survey? This will clear your previous responses.')) {
        // Clear all data
        responses = {};
        completedSections.clear();
        interactedQuestions.clear();
        clearState();
        clearSubmissionFlag();

        // Reset to first section
        currentSectionIndex = 0;

        // Hide success view and show survey
        hideSuccessView();

        // Re-render the survey
        renderSurvey();

        // Update progress to 0%
        updateProgress();

        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    // View responses function - now shows actual survey in read-only mode
    function viewResponses() {
      const savedQuestions = loadState();
      if (savedQuestions.length > 0) {
        // Enter read-only mode
        isReadOnlyMode = true;

        // Hide success view and show survey
        hideSuccessView();

        // Load the saved responses
        restoreSurveyState(savedQuestions);

        // Re-render the survey in read-only mode
        renderSurvey();
        restoreSliderValues();

        // Show all sections with responses (navigate to first section)
        currentSectionIndex = 0;
        showCurrentSection();

        // Update progress to 100%
        document.getElementById('progress-fill').style.width = '100%';
        document.getElementById('progress-text').textContent = '100%';

        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        alert('No saved responses found.');
      }
    }

    // Exit read-only mode and return to success view
    function exitReadOnlyMode() {
      isReadOnlyMode = false;
      showSuccessView();
    }

    // Save state to localStorage
    function saveState() {
      if (!surveyData) return;

      const completedQuestions = [];

      surveyData.sections.forEach((section, sectionIndex) => {
        section.questions.forEach((question, questionIndex) => {
          const questionKey = `${sectionIndex}_${questionIndex}`;

          // A question is completed if:
          // 1. Its section has been completed (user clicked Next), OR
          // 2. The user has interacted with this question or any question after it
          if (completedSections.has(sectionIndex) ||
            hasInteractedWithQuestionOrLater(sectionIndex, questionIndex)) {

            const inputType = question.input?.type || 'impSatScales';
            const questionData = {
              question: question.text,
              type: inputType
            };

            if (inputType === 'impSatScales') {
              const importanceName = `importance_${sectionIndex}_${questionIndex}`;
              const satisfactionName = `satisfaction_${sectionIndex}_${questionIndex}`;
              questionData.importance = responses[importanceName] || null;
              questionData.satisfaction = responses[satisfactionName] || null;
            } else {
              // For other input types (email, url, select)
              const responseName = `${sectionIndex}_${questionIndex}`;
              questionData.value = responses[responseName] || null;
            }

            completedQuestions.push(questionData);
          }
        });
      });

      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(completedQuestions));
      } catch (error) {
        console.warn('Failed to save state to localStorage:', error);
      }
    }

    // Load state from localStorage
    function loadState() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) return [];

        const completedQuestions = JSON.parse(stored);
        console.log('Previously completed questions:', completedQuestions);

        return completedQuestions;
      } catch (error) {
        console.warn('Failed to load state from localStorage:', error);
        return [];
      }
    }

    // Clear saved state
    function clearState() {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (error) {
        console.warn('Failed to clear state from localStorage:', error);
      }
    }

    // Restore survey state based on saved data
    function restoreSurveyState(savedQuestions) {
      if (!savedQuestions || savedQuestions.length === 0) return;

      // Create a map of saved questions by normalized text for fast lookup
      const savedQuestionsMap = new Map();
      savedQuestions.forEach(saved => {
        if (saved.question) {
          const normalizedText = saved.question.toLowerCase().trim();
          savedQuestionsMap.set(normalizedText, saved);
        }
      });

      // Iterate through current survey questions and restore values if match found
      surveyData.sections.forEach((section, sectionIndex) => {
        section.questions.forEach((question, questionIndex) => {
          const normalizedQuestionText = question.text.toLowerCase().trim();
          const savedQuestion = savedQuestionsMap.get(normalizedQuestionText);

          if (savedQuestion) {
            const inputType = question.input?.type || 'impSatScales';

            if (inputType === 'impSatScales') {
              const importanceName = `importance_${sectionIndex}_${questionIndex}`;
              const satisfactionName = `satisfaction_${sectionIndex}_${questionIndex}`;

              // Restore the values
              if (savedQuestion.importance) {
                responses[importanceName] = savedQuestion.importance;
              }
              if (savedQuestion.satisfaction) {
                responses[satisfactionName] = savedQuestion.satisfaction;
              }

              console.log(`Restored question: "${question.text}" - Importance: ${savedQuestion.importance}, Satisfaction: ${savedQuestion.satisfaction}`);
            } else {
              // For other input types (email, url, select)
              const responseName = `${sectionIndex}_${questionIndex}`;
              if (savedQuestion.value !== null && savedQuestion.value !== undefined) {
                responses[responseName] = savedQuestion.value;
                console.log(`Restored question: "${question.text}" - Value: ${savedQuestion.value}`);
              }
            }

            // Mark this question as interacted
            const questionKey = `${sectionIndex}_${questionIndex}`;
            interactedQuestions.add(questionKey);
          }
        });
      });
    }

    // Restore input values from saved responses
    function restoreSliderValues() {
      Object.keys(responses).forEach(name => {
        const input = document.querySelector(`input[name="${name}"], select[name="${name}"], textarea[name="${name}"]`);
        if (input) {
          input.value = responses[name];

          // Handle select inputs with "other" option
          if (input.tagName === 'SELECT' && input.value === 'other') {
            const questionMatch = name.match(/^(\d+)_(\d+)$/);
            if (questionMatch) {
              const sectionIndex = parseInt(questionMatch[1]);
              const questionIndex = parseInt(questionMatch[2]);
              const question = surveyData.sections[sectionIndex].questions[questionIndex];

              if (question.input?.allowOther) {
                const container = input.closest('.input-container');
                showOtherInput(container, input, sectionIndex, questionIndex);

                // Set the other input value
                setTimeout(() => {
                  const otherInput = container.querySelector('.other-input');
                  if (otherInput) {
                    otherInput.value = responses[name];
                  }
                }, 0);
              }
            }
          }
        }
      });
    }

    // Find the first incomplete question and navigate to its section
    function navigateToFirstIncompleteQuestion() {
      if (!surveyData) return;

      let firstIncompleteSection = null;
      let firstIncompleteQuestion = null;

      // Find the first incomplete question
      outerLoop: for (let sectionIndex = 0; sectionIndex < surveyData.sections.length; sectionIndex++) {
        const section = surveyData.sections[sectionIndex];

        for (let questionIndex = 0; questionIndex < section.questions.length; questionIndex++) {
          const questionKey = `${sectionIndex}_${questionIndex}`;

          // Check if this question is incomplete
          if (!completedSections.has(sectionIndex) &&
            !hasInteractedWithQuestionOrLater(sectionIndex, questionIndex)) {
            firstIncompleteSection = sectionIndex;
            firstIncompleteQuestion = { sectionIndex, questionIndex };
            break outerLoop;
          }
        }
      }

      // If we found an incomplete question, navigate to its section
      if (firstIncompleteSection !== null) {
        currentSectionIndex = firstIncompleteSection;
        showCurrentSection();

        // Scroll to the first incomplete question after a short delay to ensure DOM is ready
        setTimeout(() => {
          scrollToQuestion(firstIncompleteQuestion.sectionIndex, firstIncompleteQuestion.questionIndex);
        }, 100);
      }
    }

    // Scroll to a specific question, positioning it just below the sticky headers
    function scrollToQuestion(sectionIndex, questionIndex) {
      let targetElement;

      // If this is the first question in the section, scroll to the section header instead
      if (questionIndex === 0) {
        targetElement = document.querySelector(
          `.section-card[data-section-index="${sectionIndex}"] .section-header`
        );
        // If no section header exists, fall back to the question
        if (!targetElement) {
          targetElement = document.querySelector(
            `.section-card[data-section-index="${sectionIndex}"] .question[data-section-index="${sectionIndex}"][data-question-index="${questionIndex}"]`
          );
        }
      } else {
        targetElement = document.querySelector(
          `.section-card[data-section-index="${sectionIndex}"] .question[data-section-index="${sectionIndex}"][data-question-index="${questionIndex}"]`
        );
      }

      if (targetElement) {
        const progressBarHeight = document.querySelector('.progress-bar-container').offsetHeight;
        const titleCardHeight = document.querySelector('.title-card').offsetHeight;
        const totalStickyHeight = progressBarHeight + titleCardHeight;
        const elementTop = targetElement.getBoundingClientRect().top + window.pageYOffset;
        const targetPosition = elementTop - totalStickyHeight - 10; // 10px buffer

        window.scrollTo({
          top: Math.max(0, targetPosition),
          behavior: 'smooth'
        });
      }
    }

    // Load survey configuration
    async function loadSurveyConfig() {
      try {
        const response = await fetch('survey-config.json');
        surveyData = await response.json();

        // Check if survey was already submitted
        if (isSurveySubmitted()) {
          renderSurvey(); // Still render to show title
          showSuccessView();
          return;
        }

        // Load previously saved data
        const savedQuestions = loadState();

        renderSurvey();

        // Restore state if we have saved data
        if (savedQuestions.length > 0) {
          restoreSurveyState(savedQuestions);
          restoreSliderValues();
          updateProgress();

          // Navigate to first incomplete question
          navigateToFirstIncompleteQuestion();
        }
      } catch (error) {
        console.error('Error loading survey configuration:', error);
        document.getElementById('form-title').textContent = 'Error loading survey';
      }
    }

    // Update body padding based on floating elements height
    function updateBodyPadding() {
      const progressBarContainer = document.querySelector('.progress-bar-container');
      const titleCard = document.querySelector('.title-card');

      let totalHeight = 0;

      if (progressBarContainer) {
        totalHeight += progressBarContainer.offsetHeight;
      }

      if (titleCard && titleCard.style.display !== 'none') {
        totalHeight += titleCard.offsetHeight;
      }

      // Add a small buffer (10px)
      document.body.style.paddingTop = (totalHeight + 10) + 'px';
    }

    // Render the survey based on configuration
    function renderSurvey() {
      if (!surveyData) {
        console.warn('Cannot render survey: surveyData is not available');
        return;
      }

      document.getElementById('form-title').textContent = surveyData.title;

      // Update the webpage title
      document.title = "Survey: " + surveyData.title;

      if (surveyData.description) {
        const descriptionElement = document.getElementById('form-description');
        descriptionElement.textContent = surveyData.description;
        descriptionElement.parentElement.style.display = 'block';
      } else {
        document.getElementById('form-description').parentElement.style.display = 'none';
      }

      const formContent = document.getElementById('survey-form');
      formContent.innerHTML = '';

      surveyData.sections.forEach((section, sectionIndex) => {
        const sectionElement = createSection(section, sectionIndex);
        formContent.appendChild(sectionElement);
      });

      showCurrentSection();

      // Set initial body padding after rendering
      setTimeout(() => {
        updateBodyPadding();
      }, 0);
    }

    // Create a section element
    function createSection(section, sectionIndex) {
      const sectionDiv = document.createElement('div');
      sectionDiv.className = 'section-card';
      sectionDiv.dataset.sectionIndex = sectionIndex;

      if (section.title) {
        const headerDiv = document.createElement('div');
        headerDiv.className = 'section-header';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'section-title';
        titleDiv.textContent = section.title;
        headerDiv.appendChild(titleDiv);

        if (section.description) {
          const descDiv = document.createElement('div');
          descDiv.className = 'section-description';
          // Convert \n to <br> tags for proper line breaks
          descDiv.innerHTML = section.description.replace(/\n/g, '<br>');
          headerDiv.appendChild(descDiv);
        }

        sectionDiv.appendChild(headerDiv);
      }

      section.questions.forEach((question, questionIndex) => {
        const questionElement = createQuestion(question, sectionIndex, questionIndex);
        sectionDiv.appendChild(questionElement);
      });

      // Add navigation
      const navigation = document.createElement('div');
      navigation.className = 'navigation';

      if (isReadOnlyMode) {
        // Read-only mode navigation
        const backToSuccessBtn = document.createElement('button');
        backToSuccessBtn.type = 'button';
        backToSuccessBtn.className = 'nav-btn secondary';
        backToSuccessBtn.textContent = 'Back to Summary';
        backToSuccessBtn.addEventListener('click', exitReadOnlyMode);

        const progress = document.createElement('div');
        progress.className = 'section-progress';
        progress.textContent = `${sectionIndex + 1} of ${surveyData.sections.length} (View Only)`;

        const nextBtn = document.createElement('button');
        nextBtn.type = 'button';
        nextBtn.className = 'nav-btn';
        nextBtn.disabled = sectionIndex === surveyData.sections.length - 1;
        nextBtn.textContent = sectionIndex === surveyData.sections.length - 1 ? 'Last Section' : 'Next';
        if (!nextBtn.disabled) {
          nextBtn.addEventListener('click', () => navigateSection(1));
        }

        const backBtn = document.createElement('button');
        backBtn.type = 'button';
        backBtn.className = 'nav-btn secondary';
        backBtn.textContent = 'Previous';
        backBtn.disabled = sectionIndex === 0;
        if (!backBtn.disabled) {
          backBtn.addEventListener('click', () => navigateSection(-1));
        }

        navigation.appendChild(backToSuccessBtn);
        navigation.appendChild(progress);

        // Only show prev/next if there are multiple sections
        if (surveyData.sections.length > 1) {
          const navButtons = document.createElement('div');
          navButtons.style.display = 'flex';
          navButtons.style.gap = '8px';
          navButtons.appendChild(backBtn);
          navButtons.appendChild(nextBtn);
          navigation.appendChild(navButtons);
        }
      } else {
        // Normal mode navigation
        const backBtn = document.createElement('button');
        backBtn.type = 'button';
        backBtn.className = 'nav-btn secondary';
        backBtn.textContent = 'Back';
        backBtn.disabled = sectionIndex === 0;
        backBtn.addEventListener('click', () => {
          if (!isSubmitting) {
            navigateSection(-1);
          }
        });

        const progress = document.createElement('div');
        progress.className = 'section-progress';
        progress.textContent = `${sectionIndex + 1} of ${surveyData.sections.length}`;

        const nextBtn = document.createElement('button');
        nextBtn.type = 'button';
        nextBtn.className = 'nav-btn';
        if (sectionIndex === surveyData.sections.length - 1) {
          nextBtn.textContent = 'Submit';
          nextBtn.addEventListener('click', () => {
            if (!isSubmitting) {
              submitSurvey();
            }
          });
        } else {
          nextBtn.textContent = 'Next';
          nextBtn.addEventListener('click', () => {
            if (!isSubmitting) {
              navigateSection(1);
            }
          });
        }

        navigation.appendChild(backBtn);
        navigation.appendChild(progress);
        navigation.appendChild(nextBtn);
      }

      sectionDiv.appendChild(navigation);

      return sectionDiv;
    }

    // Create a question element
    function createQuestion(question, sectionIndex, questionIndex) {
      const questionDiv = document.createElement('div');
      questionDiv.className = 'question';
      questionDiv.dataset.sectionIndex = sectionIndex;
      questionDiv.dataset.questionIndex = questionIndex;

      const questionText = document.createElement('div');
      questionText.className = 'question-text';
      // Capitalize first letter
      const capitalizedText = question.text.charAt(0).toUpperCase() + question.text.slice(1);
      questionText.innerHTML = capitalizedText + (question.required ? '<span class="required">*</span>' : '');
      questionDiv.appendChild(questionText);

      // Create input based on question type
      const inputType = question.input?.type || 'impSatScales'; // Default to importance/satisfaction scales

      if (inputType === 'impSatScales') {
        const scalesContainer = document.createElement('div');
        scalesContainer.className = 'scales-container';

        // Importance scale (1-5)
        const importanceScale = createScale('Importance', 5,
          ['Not Important', 'Very Important'],
          `importance_${sectionIndex}_${questionIndex}`
        );
        scalesContainer.appendChild(importanceScale);

        // Satisfaction scale (1-7)
        const satisfactionScale = createScale('Satisfaction', 7,
          ['Very Unsatisfied', 'Very Satisfied'],
          `satisfaction_${sectionIndex}_${questionIndex}`
        );
        scalesContainer.appendChild(satisfactionScale);

        questionDiv.appendChild(scalesContainer);
      } else if (inputType === 'email' || inputType === 'url') {
        const inputContainer = document.createElement('div');
        inputContainer.className = 'input-container';

        const input = document.createElement('input');
        input.type = inputType;
        input.name = `${sectionIndex}_${questionIndex}`;
        input.className = 'text-input';

        if (question.placeholder) {
          input.placeholder = question.placeholder;
        }

        if (isReadOnlyMode) {
          input.disabled = true;
          input.style.opacity = '0.8';
          input.style.cursor = 'not-allowed';
        } else {
          input.addEventListener('input', (e) => {
            const questionKey = `${sectionIndex}_${questionIndex}`;
            responses[questionKey] = e.target.value;
            interactedQuestions.add(questionKey);
            console.log('interacted with ' + questionKey);
            updateProgress();
            clearValidationError(questionDiv);
          });
        }

        inputContainer.appendChild(input);
        questionDiv.appendChild(inputContainer);
      } else if (inputType === 'longText') {
        const inputContainer = document.createElement('div');
        inputContainer.className = 'input-container';

        const textarea = document.createElement('textarea');
        textarea.name = `${sectionIndex}_${questionIndex}`;
        textarea.className = 'text-input';
        textarea.rows = question.input?.rows || 4; // Default to 4 rows, configurable

        if (question.placeholder) {
          textarea.placeholder = question.placeholder;
        }

        if (isReadOnlyMode) {
          textarea.disabled = true;
          textarea.style.opacity = '0.8';
          textarea.style.cursor = 'not-allowed';
        } else {
          textarea.addEventListener('input', (e) => {
            const questionKey = `${sectionIndex}_${questionIndex}`;
            responses[questionKey] = e.target.value;
            interactedQuestions.add(questionKey);
            console.log('interacted with ' + questionKey);
            updateProgress();
            clearValidationError(questionDiv);
          });
        }

        inputContainer.appendChild(textarea);
        questionDiv.appendChild(inputContainer);
      } else if (inputType === 'select') {
        const inputContainer = document.createElement('div');
        inputContainer.className = 'input-container';

        const select = document.createElement('select');
        select.name = `${sectionIndex}_${questionIndex}`;
        select.className = 'select-input';

        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Please select...';
        defaultOption.disabled = true;
        defaultOption.selected = true;
        select.appendChild(defaultOption);

        // Add options from configuration
        if (question.input.options) {
          question.input.options.forEach(optionText => {
            const option = document.createElement('option');
            option.value = optionText;
            option.textContent = optionText;
            select.appendChild(option);
          });

          // Add "Other" option if allowOther is true
          if (question.input.allowOther) {
            const otherOption = document.createElement('option');
            otherOption.value = 'other';
            otherOption.textContent = 'Other';
            select.appendChild(otherOption);
          }
        }

        if (isReadOnlyMode) {
          select.disabled = true;
          select.style.opacity = '0.8';
          select.style.cursor = 'not-allowed';
        } else {
          select.addEventListener('change', (e) => {
            const questionKey = `${sectionIndex}_${questionIndex}`;
            responses[questionKey] = e.target.value;
            interactedQuestions.add(questionKey);
            updateProgress();
            clearValidationError(questionDiv);

            // Handle "Other" option
            if (e.target.value === 'other' && question.input.allowOther) {
              showOtherInput(inputContainer, select, sectionIndex, questionIndex);
            } else {
              hideOtherInput(inputContainer);
            }
          });
        }

        inputContainer.appendChild(select);
        questionDiv.appendChild(inputContainer);
      }

      return questionDiv;
    }

    // Helper function to show "Other" input field
    function showOtherInput(container, select, sectionIndex, questionIndex) {
      // Remove existing other input if any
      hideOtherInput(container);

      const otherInput = document.createElement('input');
      otherInput.type = 'text';
      otherInput.className = 'text-input other-input';
      otherInput.placeholder = 'Please specify...';
      otherInput.style.marginTop = '8px';

      otherInput.addEventListener('input', (e) => {
        const questionKey = `${sectionIndex}_${questionIndex}`;
        responses[questionKey] = e.target.value;
        interactedQuestions.add(questionKey);
        updateProgress();
      });

      container.appendChild(otherInput);
      otherInput.focus();
    }

    // Helper function to hide "Other" input field
    function hideOtherInput(container) {
      const existingOtherInput = container.querySelector('.other-input');
      if (existingOtherInput) {
        existingOtherInput.remove();
      }
    }

    // Create a scale element
    function createScale(label, max, labels, name) {
      const scaleDiv = document.createElement('div');
      scaleDiv.className = 'scale';

      const scaleLabel = document.createElement('div');
      scaleLabel.className = 'scale-label';
      scaleLabel.textContent = label;
      scaleDiv.appendChild(scaleLabel);

      const scaleContent = document.createElement('div');
      scaleContent.className = 'scale-content';

      // Start label
      const startLabel = document.createElement('div');
      startLabel.className = 'scale-start-label';
      startLabel.textContent = labels[0];
      scaleContent.appendChild(startLabel);

      // Slider container
      const sliderContainer = document.createElement('div');
      sliderContainer.className = 'scale-slider-container';

      // Create slider
      const slider = document.createElement('input');
      slider.type = 'range';
      slider.className = 'scale-slider';
      slider.min = 1;
      slider.max = max;
      slider.step = 1;
      slider.name = name;

      // Set default value: 1 for importance, middle for others
      const defaultValue = label === 'Importance' ? 1 : Math.ceil(max / 2);
      slider.value = defaultValue;
      responses[name] = defaultValue;

      // Disable slider if in read-only mode
      if (isReadOnlyMode) {
        slider.disabled = true;
        slider.style.opacity = '0.8';
        slider.style.cursor = 'not-allowed';
      } else {
        slider.addEventListener('input', (e) => {
          responses[name] = parseInt(e.target.value);
          clearValidationError(slider.closest('.question'));

          // Mark this question as interacted and update progress
          const questionElement = slider.closest('.question');
          const sectionIndex = parseInt(questionElement.dataset.sectionIndex);
          const questionIndex = parseInt(questionElement.dataset.questionIndex);
          const questionKey = `${sectionIndex}_${questionIndex}`;

          interactedQuestions.add(questionKey);
          updateProgress();
        });
      }

      sliderContainer.appendChild(slider);

      // Create tick marks
      const ticksContainer = document.createElement('div');
      ticksContainer.className = 'scale-ticks';
      for (let i = 1; i <= max; i++) {
        const tick = document.createElement('div');
        tick.className = 'scale-tick';
        ticksContainer.appendChild(tick);
      }
      sliderContainer.appendChild(ticksContainer);

      scaleContent.appendChild(sliderContainer);

      // End label
      const endLabel = document.createElement('div');
      endLabel.className = 'scale-end-label';
      endLabel.textContent = labels[1];
      scaleContent.appendChild(endLabel);

      scaleDiv.appendChild(scaleContent);

      return scaleDiv;
    }

    // Clear validation error
    function clearValidationError(questionElement) {
      questionElement.classList.remove('error');
      const errorElement = questionElement.querySelector('.validation-error');
      if (errorElement) {
        errorElement.remove();
      }
    }

    // Show validation error
    function showValidationError(questionElement, message) {
      questionElement.classList.add('error');

      let errorElement = questionElement.querySelector('.validation-error');
      if (!errorElement) {
        errorElement = document.createElement('div');
        errorElement.className = 'validation-error';
        questionElement.appendChild(errorElement);
      }
      errorElement.textContent = message;
    }

    // Validate form
    function validateForm() {
      let isValid = true;
      const questions = document.querySelectorAll('.question');

      questions.forEach(questionElement => {
        const sectionIndex = questionElement.dataset.sectionIndex;
        const questionIndex = questionElement.dataset.questionIndex;
        const question = surveyData.sections[sectionIndex].questions[questionIndex];

        if (question.required) {
          const inputType = question.input?.type || 'impSatScales';

          if (inputType === 'impSatScales') {
            const importanceName = `importance_${sectionIndex}_${questionIndex}`;
            const satisfactionName = `satisfaction_${sectionIndex}_${questionIndex}`;

            const hasImportance = responses[importanceName];
            const hasSatisfaction = responses[satisfactionName];

            if (!hasImportance || !hasSatisfaction) {
              showValidationError(questionElement, 'Please provide ratings for both importance and satisfaction by moving the sliders.');
              isValid = false;
            } else {
              clearValidationError(questionElement);
            }
          } else {
            // For other input types (email, url, select, longText)
            const responseName = `${sectionIndex}_${questionIndex}`;
            const responseValue = responses[responseName];

            if (!responseValue || responseValue.trim() === '') {
              showValidationError(questionElement, 'This field is required.');
              isValid = false;
            } else {
              clearValidationError(questionElement);
            }
          }
        }
      });

      return isValid;
    }

    // Update progress bar
    function updateProgress() {
      if (!surveyData) return;

      let totalQuestions = 0;
      let completedQuestions = 0;

      surveyData.sections.forEach((section, sectionIndex) => {
        // Skip sections that are excluded from progress
        if (section.excludeFromProgress === true) {
          return;
        }

        section.questions.forEach((question, questionIndex) => {
          totalQuestions++;
          const questionKey = `${sectionIndex}_${questionIndex}`;

          // A question is completed if:
          // 1. Its section has been completed (user clicked Next), OR
          // 2. The user has interacted with this question or any question after it
          if (completedSections.has(sectionIndex) ||
            hasInteractedWithQuestionOrLater(sectionIndex, questionIndex)) {
            completedQuestions++;
          }
        });
      });

      const percentage = totalQuestions > 0 ? Math.round((completedQuestions / totalQuestions) * 100) : 0;

      document.getElementById('progress-fill').style.width = percentage + '%';
      document.getElementById('progress-text').textContent = percentage + '%';

      // Update time estimation
      const remainingPercentage = 100 - percentage;
      const estimatedMinutes = Math.ceil((remainingPercentage / 100) * 5);
      const timeEstimateElement = document.getElementById('time-estimate');
      
      if (percentage === 100) {
        timeEstimateElement.textContent = 'Complete!';
      } else if (estimatedMinutes <= 1) {
        timeEstimateElement.textContent = '<1min to finish';
      } else {
        timeEstimateElement.textContent = `${estimatedMinutes}min to finish`;
      }

      // Save state whenever progress is updated
      saveState();
    }

    // Check if user has interacted with this question or any question that comes after it
    function hasInteractedWithQuestionOrLater(targetSectionIndex, targetQuestionIndex) {
      if (!surveyData) return false;

      for (let sectionIndex = 0; sectionIndex < surveyData.sections.length; sectionIndex++) {
        const section = surveyData.sections[sectionIndex];

        for (let questionIndex = 0; questionIndex < section.questions.length; questionIndex++) {
          const questionKey = `${sectionIndex}_${questionIndex}`;

          // If we've interacted with this question
          if (interactedQuestions.has(questionKey)) {
            // Check if this question comes at or after the target question
            if (sectionIndex > targetSectionIndex ||
              (sectionIndex === targetSectionIndex && questionIndex >= targetQuestionIndex)) {
              return true;
            }
          }
        }
      }

      return false;
    }

    // Show current section
    function showCurrentSection() {
      const sections = document.querySelectorAll('.section-card');
      sections.forEach((section, index) => {
        if (index === currentSectionIndex) {
          section.classList.add('active');
        } else {
          section.classList.remove('active');
        }
      });

      // Hide/show survey header based on current section's flag
      const titleCard = document.querySelector('.title-card');
      const currentSection = surveyData.sections[currentSectionIndex];
      if (currentSection && currentSection.hideSurveyHeader === true) {
        titleCard.style.display = 'none';
      } else {
        titleCard.style.display = 'block';
      }

      // Update body padding after potentially changing title card visibility
      updateBodyPadding();
    }

    // Navigate between sections
    function navigateSection(direction) {
      const newIndex = currentSectionIndex + direction;

      if (newIndex >= 0 && newIndex < surveyData.sections.length) {
        // Skip validation in read-only mode
        if (!isReadOnlyMode) {
          // Validate current section before moving forward
          if (direction > 0 && !validateCurrentSection()) {
            return;
          }

          // Mark current section as completed when moving forward
          if (direction > 0) {
            completedSections.add(currentSectionIndex);
            updateProgress();
          }
        }

        currentSectionIndex = newIndex;
        showCurrentSection();

        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    // Validate current section
    function validateCurrentSection() {
      const currentSection = document.querySelector(`.section-card[data-section-index="${currentSectionIndex}"]`);
      const questions = currentSection.querySelectorAll('.question');
      let isValid = true;

      questions.forEach(questionElement => {
        const sectionIndex = questionElement.dataset.sectionIndex;
        const questionIndex = questionElement.dataset.questionIndex;
        const question = surveyData.sections[sectionIndex].questions[questionIndex];

        if (question.required) {
          const inputType = question.input?.type || 'impSatScales';

          if (inputType === 'impSatScales') {
            const importanceName = `importance_${sectionIndex}_${questionIndex}`;
            const satisfactionName = `satisfaction_${sectionIndex}_${questionIndex}`;

            const hasImportance = responses[importanceName];
            const hasSatisfaction = responses[satisfactionName];

            if (!hasImportance || !hasSatisfaction) {
              showValidationError(questionElement, 'Please provide ratings for both importance and satisfaction by moving the sliders.');
              isValid = false;
            } else {
              clearValidationError(questionElement);
            }
          } else {
            // For other input types (email, url, select, longText)
            const responseName = `${sectionIndex}_${questionIndex}`;
            const responseValue = responses[responseName];

            if (!responseValue || responseValue.trim() === '') {
              showValidationError(questionElement, 'This field is required.');
              isValid = false;
            } else {
              clearValidationError(questionElement);
            }
          }
        }
      });

      return isValid;
    }

    // Disable/enable form interactions
    function setFormInteractionState(disabled) {
      const surveyForm = document.getElementById('survey-form');
      const container = document.querySelector('.container');

      if (disabled) {
        surveyForm.classList.add('form-disabled');
        container.style.pointerEvents = 'none';
        isSubmitting = true;
      } else {
        surveyForm.classList.remove('form-disabled');
        container.style.pointerEvents = '';
        isSubmitting = false;
      }
    }

    // Submit survey
    async function submitSurvey() {
      if (isSubmitting) {
        return; // Prevent double submission
      }

      if (validateForm()) {
        // Disable form interactions and show loading state
        setFormInteractionState(true);

        // Find and update submit button
        const submitBtn = document.querySelector('.section-card.active .nav-btn:not(.secondary)');
        if (submitBtn) {
          submitBtn.classList.add('loading');
          submitBtn.disabled = true;
        }

        // Mark the final section as completed
        completedSections.add(currentSectionIndex);
        updateProgress();

        console.log('Survey responses:', responses);

        try {
          // Store to Supabase if configured
          if (window.SupabaseUtils) {
            const result = await SupabaseUtils.storeSurveyResponse(responses, surveyData);

            if (result.success) {
              console.log('Stored in Supabase with session ID:', result.session_id);
              console.log('Total responses stored:', result.response_count);
            } else {
              console.warn('Failed to store in Supabase:', result.error);
            }
          } else {
            console.log('Supabase not configured - storing responses locally only');
          }

          // Set submission flag and show success view
          setSurveySubmitted();
          showSuccessView();

          // Keep form disabled since we're showing success view

        } catch (error) {
          console.error('Error submitting survey:', error);

          // Re-enable form interactions on error
          setFormInteractionState(false);

          // Remove loading state from submit button
          if (submitBtn) {
            submitBtn.classList.remove('loading');
            submitBtn.disabled = false;
          }

          alert('Survey responses recorded locally. There was an issue with remote storage: ' + error.message);
        }
      } else {
        // Scroll to first error
        const firstError = document.querySelector('.question.error');
        if (firstError) {
          firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    }

    // Reset survey function
    function resetSurvey() {
      // Re-enable form interactions in case they were disabled
      setFormInteractionState(false);

      responses = {};

      // Clear tracking sets
      completedSections.clear();
      interactedQuestions.clear();

      // Clear localStorage AND submission flag
      clearState();
      clearSubmissionFlag();

      // Exit read-only mode if we're in it
      isReadOnlyMode = false;

      // Reset to first section
      currentSectionIndex = 0;

      // Hide success view and show survey form
      hideSuccessView();

      // Re-render the survey to ensure fresh state
      if (surveyData) {
        renderSurvey();
      } else {
        // If surveyData is not loaded yet, reload the config
        loadSurveyConfig();
      }

      // Update progress to 0%
      updateProgress();

      // Scroll to top
      window.scrollTo({ top: 0, behavior: 'smooth' });

      console.log('Survey reset completed');
    }

    // Initialize the survey
    loadSurveyConfig();

    // Update padding on window resize
    window.addEventListener('resize', updateBodyPadding);
  </script>
</body>

</html>
    window.addEventListener('resize', updateBodyPadding);
  </script>
</body>

</html>
