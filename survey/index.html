<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Survey Application</title>
  <!-- Add Supabase CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #f0f0f0;
      min-height: 100vh;
      padding: 20px;
      padding-top: 220px;
      /* Increased to accommodate both progress bar and title card */
    }

    .progress-bar-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: white;
      z-index: 1000;
      padding: 15px 20px 10px 20px;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #673ab7, #9c27b0);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .progress-bottom {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .progress-text {
      font-size: 14px;
      font-weight: 500;
      color: #673ab7;
    }

    .reset-btn {
      background: transparent;
      color: #666;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .reset-btn:hover {
      background: #f5f5f5;
    }

    .title-card {
      position: fixed;
      top: 70px;
      /* Position below progress bar */
      left: 0;
      right: 0;
      background: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      border-bottom: 3px solid #673ab7;
      z-index: 999;
      overflow: hidden;
    }

    .header {
      display: none;
    }

    .title-section {
      background: white;
      padding: 20px 30px;
      /* Reduced padding for sticky version */
      max-width: 700px;
      margin: 0 auto;
    }

    .title-section h1 {
      font-size: 28px;
      /* Slightly smaller for sticky version */
      font-weight: 400;
      margin-bottom: 10px;
      /* Reduced margin */
      line-height: 1.3;
      color: #333;
      text-align: left;
    }

    .title-section p {
      font-size: 16px;
      /* Slightly smaller for sticky version */
      line-height: 1.5;
      color: #333;
      margin: 0;
      white-space: pre-line;
      text-align: left;
    }

    .section-card {
      margin-bottom: 20px;
      display: none;
    }

    .section-card.active {
      display: block;
    }

    .section-header {
      background: #673ab7;
      color: white;
      padding: 20px 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 16px;
    }

    .section-title {
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 5px;
    }

    .section-description {
      font-size: 14px;
      opacity: 0.9;
      line-height: 1.4;
    }

    .question {
      background: white;
      padding: 24px 30px;
      margin-bottom: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .question:last-child {
      margin-bottom: 16px;
    }

    .question-text {
      font-size: 18px;
      margin-bottom: 20px;
      color: #333;
      line-height: 1.4;
      font-weight: 500;
    }

    .question-text .required {
      color: #d93025;
      margin-left: 4px;
    }

    .scales-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .scale {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .scale-label {
      font-size: 16px;
      font-weight: bold;
      color: #333;
      min-width: 120px;
      text-align: left;
    }

    .scale-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 600px;
      min-height: 50px;
    }

    .scale-start-label {
      font-size: 18px;
      color: #666;
      min-width: 80px;
      max-width: 100px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      word-wrap: break-word;
      hyphens: auto;
      line-height: 1.2;
    }

    .scale-end-label {
      font-size: 18px;
      color: #666;
      min-width: 80px;
      max-width: 100px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      word-wrap: break-word;
      hyphens: auto;
      line-height: 1.2;
    }

    .scale-slider-container {
      flex: 1;
      margin: 0 15px;
      position: relative;
    }

    .scale-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #e0e0e0;
      outline: none;
      opacity: 0.7;
      transition: opacity 0.2s;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
    }

    .scale-slider:hover {
      opacity: 1;
    }

    .scale-slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #673ab7;
      cursor: pointer;
    }

    .scale-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #673ab7;
      cursor: pointer;
      border: none;
    }

    .scale-ticks {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      position: relative;
    }

    .scale-tick {
      width: 2px;
      height: 8px;
      background: #ccc;
      position: relative;
    }

    .scale-tick:first-child,
    .scale-tick:last-child {
      background: #666;
    }

    .validation-error {
      color: #d93025;
      font-size: 12px;
      margin-top: 8px;
    }

    .question.error .question-text {
      color: #d93025;
    }

    .question.error {
      background-color: #ffeaea;
    }

    .navigation {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 30px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .nav-btn {
      background: #673ab7;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .nav-btn:hover:not(:disabled) {
      background: #5e35b1;
    }

    .nav-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .nav-btn.secondary {
      background: transparent;
      color: #673ab7;
      border: 1px solid #673ab7;
    }

    .nav-btn.secondary:hover:not(:disabled) {
      background: #f3e5f5;
    }

    .section-progress {
      font-size: 14px;
      color: #666;
    }

    .success-view {
      display: none;
      max-width: 600px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 40px 30px;
      text-align: center;
    }

    .success-view.active {
      display: block;
    }

    .success-icon {
      font-size: 64px;
      color: #4caf50;
      margin-bottom: 20px;
    }

    .success-title {
      font-size: 28px;
      font-weight: 500;
      color: #333;
      margin-bottom: 16px;
    }

    .success-message {
      font-size: 16px;
      line-height: 1.6;
      color: #666;
      margin-bottom: 30px;
    }

    .success-actions {
      display: flex;
      gap: 16px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .success-btn {
      background: #673ab7;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      text-decoration: none;
      display: inline-block;
    }

    .success-btn:hover {
      background: #5e35b1;
    }

    .success-btn.secondary {
      background: transparent;
      color: #673ab7;
      border: 1px solid #673ab7;
    }

    .success-btn.secondary:hover {
      background: #f3e5f5;
    }

    @media (max-width: 600px) {
      body {
        padding: 10px;
        padding-top: 200px;
        /* Adjusted for mobile sticky header */
      }

      .progress-bar-container {
        padding: 10px;
        height: 60px;
      }

      .progress-text {
        font-size: 12px;
      }

      .reset-btn {
        padding: 4px 8px;
        font-size: 11px;
      }

      .title-card {
        top: 60px;
      }

      .title-section {
        padding: 15px 20px;
        /* Reduced padding for mobile */
      }

      .title-section h1 {
        font-size: 22px;
        /* Smaller for mobile sticky version */
        margin-bottom: 8px;
      }

      .title-section p {
        font-size: 14px;
        line-height: 1.4;
      }

      .question {
        padding: 20px;
      }

      .scale {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }

      .scale-label {
        min-width: auto;
        margin-bottom: 8px;
      }

      .scale-content {
        width: 100%;
        max-width: none;
        align-items: flex-start;
      }

      .scale-start-label,
      .scale-end-label {
        font-size: 14px;
        min-width: 60px;
        max-width: 80px;
        line-height: 1.1;
        padding: 0 5px;
      }

      .scale-slider-container {
        margin: 0 10px;
        align-self: center;
      }

      .navigation {
        padding: 15px 20px;
      }

      .success-view {
        padding: 30px 20px;
      }

      .success-icon {
        font-size: 48px;
      }

      .success-title {
        font-size: 24px;
      }

      .success-message {
        font-size: 14px;
      }

      .success-actions {
        flex-direction: column;
      }
    }

    @media (max-width: 480px) {
      body {
        padding-top: 180px;
        /* Further adjusted for smaller screens */
      }

      .title-card {
        top: 60px;
      }

      .scale-start-label,
      .scale-end-label {
        font-size: 12px;
        min-width: 50px;
        max-width: 70px;
        padding: 0 3px;
      }

      .scale-slider-container {
        margin: 0 8px;
      }

      .title-section {
        padding: 15px 20px 10px 20px;
        /* More compact for small screens */
      }

      .title-section h1 {
        font-size: 20px;
        margin-bottom: 6px;
      }

      .title-section p {
        font-size: 13px;
        line-height: 1.3;
      }
    }
  </style>
</head>

<body>
  <div class="progress-bar-container">
    <div class="progress-bottom">
      <div class="progress-text" id="progress-text">0%</div>
      <button class="reset-btn" id="reset-btn" onclick="resetSurvey()">Reset Survey</button>
    </div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
  </div>

  <div class="title-card">
    <div class="title-section">
      <h1 id="form-title">Loading...</h1>
      <p id="form-description"></p>
    </div>
  </div>

  <div class="container">
    <div id="success-view" class="success-view">
      <div class="success-icon">✓</div>
      <h2 class="success-title">Thank You!</h2>
      <p class="success-message">
        Your survey responses have been successfully submitted. We appreciate your valuable feedback and the time you
        took to complete this survey.
      </p>
      <div class="success-actions">
        <button class="success-btn secondary" onclick="startNewSurvey()">Take Survey Again</button>
        <button class="success-btn" onclick="viewResponses()">View My Responses</button>
      </div>
    </div>

    <form id="survey-form">
      <!-- Sections will be populated here -->
    </form>
  </div>

  <script src="supabase-utils.js"></script>
  <script>
    let surveyData = null;
    let responses = {};
    let currentSectionIndex = 0;
    let completedSections = new Set(); // Track which sections have been completed
    let interactedQuestions = new Set(); // Track which questions have been interacted with
    let isReadOnlyMode = false; // Track if we're in read-only mode

    // Local storage keys
    const STORAGE_KEY = 'survey_state';
    const SUBMITTED_KEY = 'survey_submitted';

    // Submission flag management
    function setSurveySubmitted() {
      try {
        localStorage.setItem(SUBMITTED_KEY, 'true');
      } catch (error) {
        console.warn('Failed to set submission flag:', error);
      }
    }

    function isSurveySubmitted() {
      try {
        return localStorage.getItem(SUBMITTED_KEY) === 'true';
      } catch (error) {
        console.warn('Failed to check submission flag:', error);
        return false;
      }
    }

    function clearSubmissionFlag() {
      try {
        localStorage.removeItem(SUBMITTED_KEY);
      } catch (error) {
        console.warn('Failed to clear submission flag:', error);
      }
    }

    // Show success view
    function showSuccessView() {
      document.getElementById('success-view').classList.add('active');
      document.getElementById('survey-form').style.display = 'none';

      // Update progress to 100%
      document.getElementById('progress-fill').style.width = '100%';
      document.getElementById('progress-text').textContent = '100%';
    }

    // Hide success view
    function hideSuccessView() {
      document.getElementById('success-view').classList.remove('active');
      document.getElementById('survey-form').style.display = 'block';
    }

    // Start new survey
    function startNewSurvey() {
      if (confirm('Are you sure you want to start a new survey? This will clear your previous responses.')) {
        // Clear all data
        responses = {};
        completedSections.clear();
        interactedQuestions.clear();
        clearState();
        clearSubmissionFlag();

        // Reset to first section
        currentSectionIndex = 0;

        // Hide success view and show survey
        hideSuccessView();

        // Re-render the survey
        renderSurvey();

        // Update progress to 0%
        updateProgress();

        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    // View responses function - now shows actual survey in read-only mode
    function viewResponses() {
      const savedQuestions = loadState();
      if (savedQuestions.length > 0) {
        // Enter read-only mode
        isReadOnlyMode = true;

        // Hide success view and show survey
        hideSuccessView();

        // Load the saved responses
        restoreSurveyState(savedQuestions);

        // Re-render the survey in read-only mode
        renderSurvey();
        restoreSliderValues();

        // Show all sections with responses (navigate to first section)
        currentSectionIndex = 0;
        showCurrentSection();

        // Update progress to 100%
        document.getElementById('progress-fill').style.width = '100%';
        document.getElementById('progress-text').textContent = '100%';

        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        alert('No saved responses found.');
      }
    }

    // Exit read-only mode and return to success view
    function exitReadOnlyMode() {
      isReadOnlyMode = false;
      showSuccessView();
    }

    // Save state to localStorage
    function saveState() {
      if (!surveyData) return;

      const completedQuestions = [];

      surveyData.sections.forEach((section, sectionIndex) => {
        section.questions.forEach((question, questionIndex) => {
          const questionKey = `${sectionIndex}_${questionIndex}`;

          // A question is completed if:
          // 1. Its section has been completed (user clicked Next), OR
          // 2. The user has interacted with this question or any question after it
          if (completedSections.has(sectionIndex) ||
            hasInteractedWithQuestionOrLater(sectionIndex, questionIndex)) {

            const importanceName = `importance_${sectionIndex}_${questionIndex}`;
            const satisfactionName = `satisfaction_${sectionIndex}_${questionIndex}`;

            completedQuestions.push({
              question: question.text,
              importance: responses[importanceName] || null,
              satisfaction: responses[satisfactionName] || null
            });
          }
        });
      });

      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(completedQuestions));
      } catch (error) {
        console.warn('Failed to save state to localStorage:', error);
      }
    }

    // Load state from localStorage
    function loadState() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) return [];

        const completedQuestions = JSON.parse(stored);
        console.log('Previously completed questions:', completedQuestions);

        return completedQuestions;
      } catch (error) {
        console.warn('Failed to load state from localStorage:', error);
        return [];
      }
    }

    // Clear saved state
    function clearState() {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (error) {
        console.warn('Failed to clear state from localStorage:', error);
      }
    }

    // Restore survey state based on saved data
    function restoreSurveyState(savedQuestions) {
      if (!savedQuestions || savedQuestions.length === 0) return;

      // Create a map of saved questions by normalized text for fast lookup
      const savedQuestionsMap = new Map();
      savedQuestions.forEach(saved => {
        if (saved.question) {
          const normalizedText = saved.question.toLowerCase().trim();
          savedQuestionsMap.set(normalizedText, saved);
        }
      });

      // Iterate through current survey questions and restore values if match found
      surveyData.sections.forEach((section, sectionIndex) => {
        section.questions.forEach((question, questionIndex) => {
          const normalizedQuestionText = question.text.toLowerCase().trim();
          const savedQuestion = savedQuestionsMap.get(normalizedQuestionText);

          if (savedQuestion) {
            const importanceName = `importance_${sectionIndex}_${questionIndex}`;
            const satisfactionName = `satisfaction_${sectionIndex}_${questionIndex}`;

            // Restore the values
            if (savedQuestion.importance) {
              responses[importanceName] = savedQuestion.importance;
            }
            if (savedQuestion.satisfaction) {
              responses[satisfactionName] = savedQuestion.satisfaction;
            }

            // Mark this question as interacted
            const questionKey = `${sectionIndex}_${questionIndex}`;
            interactedQuestions.add(questionKey);

            console.log(`Restored question: "${question.text}" - Importance: ${savedQuestion.importance}, Satisfaction: ${savedQuestion.satisfaction}`);
          }
        });
      });
    }

    // Restore slider values from saved responses
    function restoreSliderValues() {
      Object.keys(responses).forEach(name => {
        const slider = document.querySelector(`input[name="${name}"]`);
        if (slider) {
          slider.value = responses[name];
        }
      });
    }

    // Find the first incomplete question and navigate to its section
    function navigateToFirstIncompleteQuestion() {
      if (!surveyData) return;

      let firstIncompleteSection = null;
      let firstIncompleteQuestion = null;

      // Find the first incomplete question
      outerLoop: for (let sectionIndex = 0; sectionIndex < surveyData.sections.length; sectionIndex++) {
        const section = surveyData.sections[sectionIndex];

        for (let questionIndex = 0; questionIndex < section.questions.length; questionIndex++) {
          const questionKey = `${sectionIndex}_${questionIndex}`;

          // Check if this question is incomplete
          if (!completedSections.has(sectionIndex) &&
            !hasInteractedWithQuestionOrLater(sectionIndex, questionIndex)) {
            firstIncompleteSection = sectionIndex;
            firstIncompleteQuestion = { sectionIndex, questionIndex };
            break outerLoop;
          }
        }
      }

      // If we found an incomplete question, navigate to its section
      if (firstIncompleteSection !== null) {
        currentSectionIndex = firstIncompleteSection;
        showCurrentSection();

        // Scroll to the first incomplete question after a short delay to ensure DOM is ready
        setTimeout(() => {
          scrollToQuestion(firstIncompleteQuestion.sectionIndex, firstIncompleteQuestion.questionIndex);
        }, 100);
      }
    }

    // Scroll to a specific question, positioning it just below the sticky headers
    function scrollToQuestion(sectionIndex, questionIndex) {
      const questionElement = document.querySelector(
        `.section-card[data-section-index="${sectionIndex}"] .question[data-section-index="${sectionIndex}"][data-question-index="${questionIndex}"]`
      );

      if (questionElement) {
        const progressBarHeight = document.querySelector('.progress-bar-container').offsetHeight;
        const titleCardHeight = document.querySelector('.title-card').offsetHeight;
        const totalStickyHeight = progressBarHeight + titleCardHeight;
        const elementTop = questionElement.getBoundingClientRect().top + window.pageYOffset;
        const targetPosition = elementTop - totalStickyHeight - 10; // 10px buffer

        window.scrollTo({
          top: Math.max(0, targetPosition),
          behavior: 'smooth'
        });
      }
    }

    // Load survey configuration
    async function loadSurveyConfig() {
      try {
        const response = await fetch('survey-config.json');
        surveyData = await response.json();

        // Check if survey was already submitted
        if (isSurveySubmitted()) {
          renderSurvey(); // Still render to show title
          showSuccessView();
          return;
        }

        // Load previously saved data
        const savedQuestions = loadState();

        renderSurvey();

        // Restore state if we have saved data
        if (savedQuestions.length > 0) {
          restoreSurveyState(savedQuestions);
          restoreSliderValues();
          updateProgress();

          // Navigate to first incomplete question
          navigateToFirstIncompleteQuestion();
        }
      } catch (error) {
        console.error('Error loading survey configuration:', error);
        document.getElementById('form-title').textContent = 'Error loading survey';
      }
    }

    // Render the survey based on configuration
    function renderSurvey() {
      document.getElementById('form-title').textContent = surveyData.title;

      if (surveyData.description) {
        const descriptionElement = document.getElementById('form-description');
        descriptionElement.textContent = surveyData.description;
        descriptionElement.parentElement.style.display = 'block';
      } else {
        document.getElementById('form-description').parentElement.style.display = 'none';
      }

      const formContent = document.getElementById('survey-form');
      formContent.innerHTML = '';

      surveyData.sections.forEach((section, sectionIndex) => {
        const sectionElement = createSection(section, sectionIndex);
        formContent.appendChild(sectionElement);
      });

      showCurrentSection();
    }

    // Create a section element
    function createSection(section, sectionIndex) {
      const sectionDiv = document.createElement('div');
      sectionDiv.className = 'section-card';
      sectionDiv.dataset.sectionIndex = sectionIndex;

      if (section.title) {
        const headerDiv = document.createElement('div');
        headerDiv.className = 'section-header';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'section-title';
        titleDiv.textContent = section.title;
        headerDiv.appendChild(titleDiv);

        if (section.description) {
          const descDiv = document.createElement('div');
          descDiv.className = 'section-description';
          descDiv.textContent = section.description;
          headerDiv.appendChild(descDiv);
        }

        sectionDiv.appendChild(headerDiv);
      }

      section.questions.forEach((question, questionIndex) => {
        const questionElement = createQuestion(question, sectionIndex, questionIndex);
        sectionDiv.appendChild(questionElement);
      });

      // Add navigation
      const navigation = document.createElement('div');
      navigation.className = 'navigation';

      if (isReadOnlyMode) {
        // Read-only mode navigation
        const backToSuccessBtn = document.createElement('button');
        backToSuccessBtn.type = 'button';
        backToSuccessBtn.className = 'nav-btn secondary';
        backToSuccessBtn.textContent = 'Back to Summary';
        backToSuccessBtn.addEventListener('click', exitReadOnlyMode);

        const progress = document.createElement('div');
        progress.className = 'section-progress';
        progress.textContent = `${sectionIndex + 1} of ${surveyData.sections.length} (View Only)`;

        const nextBtn = document.createElement('button');
        nextBtn.type = 'button';
        nextBtn.className = 'nav-btn';
        nextBtn.disabled = sectionIndex === surveyData.sections.length - 1;
        nextBtn.textContent = sectionIndex === surveyData.sections.length - 1 ? 'Last Section' : 'Next';
        if (!nextBtn.disabled) {
          nextBtn.addEventListener('click', () => navigateSection(1));
        }

        const backBtn = document.createElement('button');
        backBtn.type = 'button';
        backBtn.className = 'nav-btn secondary';
        backBtn.textContent = 'Previous';
        backBtn.disabled = sectionIndex === 0;
        if (!backBtn.disabled) {
          backBtn.addEventListener('click', () => navigateSection(-1));
        }

        navigation.appendChild(backToSuccessBtn);
        navigation.appendChild(progress);

        // Only show prev/next if there are multiple sections
        if (surveyData.sections.length > 1) {
          const navButtons = document.createElement('div');
          navButtons.style.display = 'flex';
          navButtons.style.gap = '8px';
          navButtons.appendChild(backBtn);
          navButtons.appendChild(nextBtn);
          navigation.appendChild(navButtons);
        }
      } else {
        // Normal mode navigation
        const backBtn = document.createElement('button');
        backBtn.type = 'button';
        backBtn.className = 'nav-btn secondary';
        backBtn.textContent = 'Back';
        backBtn.disabled = sectionIndex === 0;
        backBtn.addEventListener('click', () => navigateSection(-1));

        const progress = document.createElement('div');
        progress.className = 'section-progress';
        progress.textContent = `${sectionIndex + 1} of ${surveyData.sections.length}`;

        const nextBtn = document.createElement('button');
        nextBtn.type = 'button';
        nextBtn.className = 'nav-btn';
        if (sectionIndex === surveyData.sections.length - 1) {
          nextBtn.textContent = 'Submit';
          nextBtn.addEventListener('click', submitSurvey);
        } else {
          nextBtn.textContent = 'Next';
          nextBtn.addEventListener('click', () => navigateSection(1));
        }

        navigation.appendChild(backBtn);
        navigation.appendChild(progress);
        navigation.appendChild(nextBtn);
      }

      sectionDiv.appendChild(navigation);

      return sectionDiv;
    }

    // Create a question element
    function createQuestion(question, sectionIndex, questionIndex) {
      const questionDiv = document.createElement('div');
      questionDiv.className = 'question';
      questionDiv.dataset.sectionIndex = sectionIndex;
      questionDiv.dataset.questionIndex = questionIndex;

      const questionText = document.createElement('div');
      questionText.className = 'question-text';
      // Capitalize first letter
      const capitalizedText = question.text.charAt(0).toUpperCase() + question.text.slice(1);
      questionText.innerHTML = capitalizedText + (question.required ? '<span class="required">*</span>' : '');
      questionDiv.appendChild(questionText);

      const scalesContainer = document.createElement('div');
      scalesContainer.className = 'scales-container';

      // Importance scale (1-5)
      const importanceScale = createScale('Importance', 5,
        ['Not Important', 'Very Important'],
        `importance_${sectionIndex}_${questionIndex}`
      );
      scalesContainer.appendChild(importanceScale);

      // Satisfaction scale (1-7)
      const satisfactionScale = createScale('Satisfaction', 7,
        ['Very Unsatisfied', 'Very Satisfied'],
        `satisfaction_${sectionIndex}_${questionIndex}`
      );
      scalesContainer.appendChild(satisfactionScale);

      questionDiv.appendChild(scalesContainer);

      return questionDiv;
    }

    // Create a scale element
    function createScale(label, max, labels, name) {
      const scaleDiv = document.createElement('div');
      scaleDiv.className = 'scale';

      const scaleLabel = document.createElement('div');
      scaleLabel.className = 'scale-label';
      scaleLabel.textContent = label;
      scaleDiv.appendChild(scaleLabel);

      const scaleContent = document.createElement('div');
      scaleContent.className = 'scale-content';

      // Start label
      const startLabel = document.createElement('div');
      startLabel.className = 'scale-start-label';
      startLabel.textContent = labels[0];
      scaleContent.appendChild(startLabel);

      // Slider container
      const sliderContainer = document.createElement('div');
      sliderContainer.className = 'scale-slider-container';

      // Create slider
      const slider = document.createElement('input');
      slider.type = 'range';
      slider.className = 'scale-slider';
      slider.min = 1;
      slider.max = max;
      slider.step = 1;
      slider.name = name;

      // Set default value to middle
      const middleValue = Math.ceil(max / 2);
      slider.value = middleValue;
      responses[name] = middleValue;

      // Disable slider if in read-only mode
      if (isReadOnlyMode) {
        slider.disabled = true;
        slider.style.opacity = '0.8';
        slider.style.cursor = 'not-allowed';
      } else {
        slider.addEventListener('input', (e) => {
          responses[name] = parseInt(e.target.value);
          clearValidationError(slider.closest('.question'));

          // Mark this question as interacted and update progress
          const questionElement = slider.closest('.question');
          const sectionIndex = parseInt(questionElement.dataset.sectionIndex);
          const questionIndex = parseInt(questionElement.dataset.questionIndex);
          const questionKey = `${sectionIndex}_${questionIndex}`;

          interactedQuestions.add(questionKey);
          updateProgress();
        });
      }

      sliderContainer.appendChild(slider);

      // Create tick marks
      const ticksContainer = document.createElement('div');
      ticksContainer.className = 'scale-ticks';
      for (let i = 1; i <= max; i++) {
        const tick = document.createElement('div');
        tick.className = 'scale-tick';
        ticksContainer.appendChild(tick);
      }
      sliderContainer.appendChild(ticksContainer);

      scaleContent.appendChild(sliderContainer);

      // End label
      const endLabel = document.createElement('div');
      endLabel.className = 'scale-end-label';
      endLabel.textContent = labels[1];
      scaleContent.appendChild(endLabel);

      scaleDiv.appendChild(scaleContent);

      return scaleDiv;
    }

    // Clear validation error
    function clearValidationError(questionElement) {
      questionElement.classList.remove('error');
      const errorElement = questionElement.querySelector('.validation-error');
      if (errorElement) {
        errorElement.remove();
      }
    }

    // Show validation error
    function showValidationError(questionElement, message) {
      questionElement.classList.add('error');

      let errorElement = questionElement.querySelector('.validation-error');
      if (!errorElement) {
        errorElement = document.createElement('div');
        errorElement.className = 'validation-error';
        questionElement.appendChild(errorElement);
      }
      errorElement.textContent = message;
    }

    // Validate form
    function validateForm() {
      let isValid = true;
      const questions = document.querySelectorAll('.question');

      questions.forEach(questionElement => {
        const sectionIndex = questionElement.dataset.sectionIndex;
        const questionIndex = questionElement.dataset.questionIndex;
        const question = surveyData.sections[sectionIndex].questions[questionIndex];

        if (question.required) {
          const importanceName = `importance_${sectionIndex}_${questionIndex}`;
          const satisfactionName = `satisfaction_${sectionIndex}_${questionIndex}`;

          const hasImportance = responses[importanceName];
          const hasSatisfaction = responses[satisfactionName];

          if (!hasImportance || !hasSatisfaction) {
            showValidationError(questionElement, 'Please provide ratings for both importance and satisfaction by moving the sliders.');
            isValid = false;
          } else {
            clearValidationError(questionElement);
          }
        }
      });

      return isValid;
    }

    // Update progress bar
    function updateProgress() {
      if (!surveyData) return;

      let totalQuestions = 0;
      let completedQuestions = 0;

      surveyData.sections.forEach((section, sectionIndex) => {
        section.questions.forEach((question, questionIndex) => {
          totalQuestions++;
          const questionKey = `${sectionIndex}_${questionIndex}`;

          // A question is completed if:
          // 1. Its section has been completed (user clicked Next), OR
          // 2. The user has interacted with this question or any question after it
          if (completedSections.has(sectionIndex) ||
            hasInteractedWithQuestionOrLater(sectionIndex, questionIndex)) {
            completedQuestions++;
          }
        });
      });

      const percentage = totalQuestions > 0 ? Math.round((completedQuestions / totalQuestions) * 100) : 0;

      document.getElementById('progress-fill').style.width = percentage + '%';
      document.getElementById('progress-text').textContent = percentage + '%';

      // Save state whenever progress is updated
      saveState();
    }

    // Check if user has interacted with this question or any question that comes after it
    function hasInteractedWithQuestionOrLater(targetSectionIndex, targetQuestionIndex) {
      if (!surveyData) return false;

      for (let sectionIndex = 0; sectionIndex < surveyData.sections.length; sectionIndex++) {
        const section = surveyData.sections[sectionIndex];

        for (let questionIndex = 0; questionIndex < section.questions.length; questionIndex++) {
          const questionKey = `${sectionIndex}_${questionIndex}`;

          // If we've interacted with this question
          if (interactedQuestions.has(questionKey)) {
            // Check if this question comes at or after the target question
            if (sectionIndex > targetSectionIndex ||
              (sectionIndex === targetSectionIndex && questionIndex >= targetQuestionIndex)) {
              return true;
            }
          }
        }
      }

      return false;
    }

    // Show current section
    function showCurrentSection() {
      const sections = document.querySelectorAll('.section-card');
      sections.forEach((section, index) => {
        if (index === currentSectionIndex) {
          section.classList.add('active');
        } else {
          section.classList.remove('active');
        }
      });
    }

    // Navigate between sections
    function navigateSection(direction) {
      const newIndex = currentSectionIndex + direction;

      if (newIndex >= 0 && newIndex < surveyData.sections.length) {
        // Skip validation in read-only mode
        if (!isReadOnlyMode) {
          // Validate current section before moving forward
          if (direction > 0 && !validateCurrentSection()) {
            return;
          }

          // Mark current section as completed when moving forward
          if (direction > 0) {
            completedSections.add(currentSectionIndex);
            updateProgress();
          }
        }

        currentSectionIndex = newIndex;
        showCurrentSection();

        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    // Validate current section
    function validateCurrentSection() {
      const currentSection = document.querySelector(`.section-card[data-section-index="${currentSectionIndex}"]`);
      const questions = currentSection.querySelectorAll('.question');
      let isValid = true;

      questions.forEach(questionElement => {
        const sectionIndex = questionElement.dataset.sectionIndex;
        const questionIndex = questionElement.dataset.questionIndex;
        const question = surveyData.sections[sectionIndex].questions[questionIndex];

        if (question.required) {
          const importanceName = `importance_${sectionIndex}_${questionIndex}`;
          const satisfactionName = `satisfaction_${sectionIndex}_${questionIndex}`;

          const hasImportance = responses[importanceName];
          const hasSatisfaction = responses[satisfactionName];

          if (!hasImportance || !hasSatisfaction) {
            showValidationError(questionElement, 'Please provide ratings for both importance and satisfaction by moving the sliders.');
            isValid = false;
          } else {
            clearValidationError(questionElement);
          }
        }
      });

      return isValid;
    }

    // Submit survey
    async function submitSurvey() {
      if (validateForm()) {
        // Mark the final section as completed
        completedSections.add(currentSectionIndex);
        updateProgress();

        console.log('Survey responses:', responses);

        try {
          // Store to Supabase if configured
          if (window.SupabaseUtils) {
            const result = await SupabaseUtils.storeSurveyResponse(responses, surveyData);

            if (result.success) {
              console.log('Stored in Supabase with session ID:', result.session_id);
              console.log('Total responses stored:', result.response_count);
            } else {
              console.warn('Failed to store in Supabase:', result.error);
            }
          } else {
            console.log('Supabase not configured - storing responses locally only');
          }

          // Set submission flag and show success view
          setSurveySubmitted();
          showSuccessView();

        } catch (error) {
          console.error('Error submitting survey:', error);
          alert('Survey responses recorded locally. There was an issue with remote storage: ' + error.message);
        }
      } else {
        // Scroll to first error
        const firstError = document.querySelector('.question.error');
        if (firstError) {
          firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    }

    // Reset survey function
    function resetSurvey() {
      // Don't allow reset in read-only mode
      if (isReadOnlyMode) {
        alert('Cannot reset survey while in view mode. Please return to summary first.');
        return;
      }

      if (confirm('Are you sure you want to reset the survey? This will clear all your answers.')) {
        // Clear all responses
        responses = {};

        // Clear tracking sets
        completedSections.clear();
        interactedQuestions.clear();

        // Clear localStorage but keep submission flag
        clearState();

        // Reset to first section
        currentSectionIndex = 0;

        // Re-render the survey
        renderSurvey();

        // Update progress to 0%
        updateProgress();

        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    // Initialize the survey
    loadSurveyConfig();
  </script>
</body>

</html>
